---
title: hash算法基本总结
date: 2017-10-29 10:07:37
tags:
categories: 计算机基础
---

# 基本介绍
## 定义
[散列算法](https://baike.baidu.com/item/great%20firewall?fromenter=GFW&subLemmaId=987882 "维基百科")又称hash函数，维基百科的介绍：
一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。

简而言之，hash算法就是从一任意文件得到一个较小的数字的方法
## 构造hash函数的方法
* 直接寻址法：取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数）

* 数字分析法：分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
* 平方取中法：取keyword平方后的中间几位作为散列地址。

* 折叠法：将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。

* 随机数法：选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。

* 除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，easy产生同义词。
查找的性能分析
## hash算法应有的特点
一个优秀的 hash 算法，将能实现：

* 正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。

* 逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。

* 输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。
~~~
MD5("version1") = "966634ebf2fc135707d6753692bf4b1e";
MD5("version2") = "2e0e95285f08a07dea17e7ee111b21c8";
~~~
* 冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。
但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。

# 应用场景
## 著名的hash算法
* MD4
MD4(RFC 1320)是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。它适用在32位字长的处理器上用快速软件实现--它是基于 32 位操作数的位操作来实现的。MD4已经被证明不够安全
* MD5
MD5(RFC 1321)是 Rivest 于1991年对MD4的改进版本号。它对输入仍以512位分组，其输出是4个32位字的级联，与 MD4 同样。MD5比MD4来得复杂，而且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好
。但MD5已经被王小云教授破解了。
* SHA 
SHA1是由NIST NSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举(brute-force)性更好。SHA-1 设计时基于和MD4同样原理,而且模仿了该算法。SHA-1 已被证明不具"强抗碰撞性"。
* 为了提高安全性，NIST 还设计出了 SHA-224、SHA-256、SHA-384，和 SHA-512 算法（统称为 SHA-2），跟 SHA-1 算法原理类似。SHA-3 相关算法也已被提出。
## 具体小例子
一场拍卖会中，物品是价高者得，如果每个人只有一次出价机会，同时提交自己的价格后，最后一起公布，出价最高则胜出。这种形式存在作弊的可能，如果有出价者能 hack 进后台，然后将自己的价格改为最高价 +1，则能以最低的代价获得胜利。如何杜绝这种作弊呢？

答案很简单，参与者都提交自身出价的 hash 值就可以了，即使有人能黑进后台也无法得知明文价格，等到公布之时，再对比原出价与 hash 值是否对应即可。是不是很巧妙？

## 密码学应用
这种思想其实在密码学上运用很多。

在密码学中，hash算法的作用主要是用于消息摘要和签名，换句话说，它主要用于对整个消息的完整性进行校验。

举个例子，我们登陆的时候都需要输入密码，那么如果明文保存这个密码，那么黑客就很容易窃取大家的密码来登陆，特别不安全。那么就一这么一个方法，使用hash算法生成一个密码的签名，后台只保存这个签名值。由于hash算法是不可逆的，那么黑客即便得到这个签名，也丝毫没有用处；而如果你在网站登陆界面上输入你的密码，那么知乎后台就会重新计算一下这个hash值，与网站中储存的原hash值进行比对，如果相同，证明你拥有这个账户的密码，那么就会允许你登陆。银行也是如此，银行是万万不敢保存用户密码的原文的，只会保存密码的hash值而而已。在这些应用场景里，对于抗碰撞和抗篡改能力要求极高，对速度的要求在其次。一个设计良好的hash算法，其抗碰撞能力是很高的。以MD5为例，其输出长度为128位，设计预期碰撞概率为1/2^128，这是一个极小极小的数字——而即便是在MD5被王小云教授破解之后，碰撞概率也极低。
## hash在管理数据结构中的应用
在用到hash进行管理的数据结构中，就对速度比较重视，对抗碰撞不太看中，只要保证hash均匀分布就可以。比如hashmap，hash值（key）存在的目的是加速键值对的查找，key的作用是为了将元素适当地放在各个桶里，对于抗碰撞的要求没有那么高。换句话说，hash出来的key，只要保证value大致均匀的放在不同的桶里就可以了。
## hash设计思想
举微信红包的例子，后台工程师为了防止抢红包时，用户的流量都涌进同个服务器，在同个 DB 上读写而导致的性能下降，采用了通过 hash 算法来分流的策略。每个红包创建的时候分配一个 ID，通过算法将 ID 映射到不同的逻辑服务器，一气呵成的解决方案。这里体现的是 hash 算法的另一种思想：【hash 能以 O（1）的复杂度将内容映射到位置】。这种应用 hash 的思路非常常见
# 碰撞
## 基本碰撞
举个特别简单的hash算法
~~~
#  构造散列函数
def hash(a):
    return a % 8

#  测试散列函数功能
print(hash(233))
print(hash(234))
print(hash(235))
~~~
上面我们尝试的散列算法得到的值一定是一个不大于8的自然数，因此，如果我们随便拿9个数去计算，肯定至少会得到两个相同的值，这种情况就叫做散列算法的「碰撞」（Collision）。

这很容易理解，因为作为一种可用的散列算法，其位数一定是有限的，也就是说它能记录的文件是有限的——而文件数量是无限的，两个文件指纹发生碰撞的概率永远不会是零。

但这并不意味着散列算法就不能用了，因为凡事都要考虑代价，买光所有彩票去中一次头奖是毫无意义的。现代散列算法所存在的理由就是，它的不可逆性能在较大概率上得到实现，也就是说，发现碰撞的概率很小，这种碰撞能被利用的概率更小。

随意找到一组碰撞是有可能的，只要穷举就可以。散列算法得到的指纹位数是有限的，比如MD5算法指纹字长为128位，意味着只要我们穷举2^128次，就肯定能得到一组碰撞——当然，这个时间代价是难以想象的，而更重要的是，仅仅找到一组碰撞并没有什么实际意义。更有意义的是，如果我们已经有了一组指纹，能否找到一个原始文件，让它的散列计算结果等于这组指纹。如果这一点被实现，我们就可以很容易地篡改和伪造网络证书、密码等关键信息。

## md5碰撞实例
之所以说MD5过时，是因为它在某些时候已经很难表现出散列算法的某些优势——比如在应对文件的微小修改时，散列算法得到的指纹结果应当有显著的不同，而下面的程序说明了MD5并不能实现这一点.
~~~
import hashlib

#  两段HEX字节串，注意它们有细微差别
a = bytearray.fromhex("0e306561559aa787d00bc6f70bbdfe3404cf03659e704f8534c00ffb659c4c8740cc942feb2da115a3f4155cbb8607497386656d7d1f34a42059d78f5a8dd1ef")

b = bytearray.fromhex("0e306561559aa787d00bc6f70bbdfe3404cf03659e744f8534c00ffb659c4c8740cc942feb2da115a3f415dcbb8607497386656d7d1f34a42059d78f5a8dd1ef")

#  输出MD5，它们的结果一致
print(hashlib.md5(a).hexdigest())
print(hashlib.md5(b).hexdigest())
~~~
运行结果:
~~~
cee9a457e790cf20d4bdaa6d69f01e41
cee9a457e790cf20d4bdaa6d69f01e41
~~~
而诸如此类的碰撞案例还有很多，上面只是原始文件相对较小的一个例子。事实上现在我们用智能手机只要数秒就能找到MD5的一个碰撞案例，因此，MD5在数年前就已经不被推荐作为应用中的散列算法方案，取代它的是SHA家族算法，也就是安全散列算法（Secure Hash Algorithm，缩写为SHA）。
## SHA-1碰撞
SHA-1是1995年国家标准技术局NIST（National Institute of Standards and Technology）于1995年标准化的哈希函数。与前身MD5相比，SHA-1的输出长度更长（MD5输出长度为128bit，而SHA-1的输出长度为160bit）那么意味者，如果要暴力破解SHA-1，需要2^160次计算

虽然这么寻找碰撞一定是可行的，但计算代价太大了，2^{160}这个数量级有多夸张？对比一下，全地球沙子的数量大约为2^84。然而，我们可以通过概率方法寻找。我们放宽条件：如果降低一定的计算量，能不能有比较高的概率找到一组碰撞呢？这就是著名的生日攻击（Birthday Attack）了。

一个屋子里必须有366个人（一年有365天，不考虑闰年）才能保证一定有2个人生日相同。然而，如果一个屋子里有23个人，则有50%的概率2个人生日相同。所以，如果进行大约2^80次运算，就有一半的概率发生碰撞。

今年2月23日，google宣布实现了SHA-1碰撞，只用进行2^61次运算就能将文件的一部分进行替换，构造出不同的文件，但SHA-1结果相同，具体：
[https://www.zhihu.com/question/56234281](https://www.zhihu.com/question/56234281)


Reference：
https://www.zhihu.com/question/56234281
http://www.jianshu.com/p/bf1d7eee28d0
https://jizhi.im/blog/post/sha1decrypt